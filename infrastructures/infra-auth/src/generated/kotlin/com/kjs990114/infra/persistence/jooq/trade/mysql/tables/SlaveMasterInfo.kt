/*
 * This file is generated by jOOQ.
 */
package com.kjs990114.infra.persistence.jooq.trade.mysql.tables


import com.kjs990114.infra.persistence.jooq.trade.mysql.Mysql
import com.kjs990114.infra.persistence.jooq.trade.mysql.keys.KEY_SLAVE_MASTER_INFO_PRIMARY
import com.kjs990114.infra.persistence.jooq.trade.mysql.tables.records.SlaveMasterInfoRecord

import kotlin.collections.Collection

import org.jooq.Condition
import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.InverseForeignKey
import org.jooq.Name
import org.jooq.PlainSQL
import org.jooq.QueryPart
import org.jooq.Record
import org.jooq.SQL
import org.jooq.Schema
import org.jooq.Select
import org.jooq.Stringly
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.UniqueKey
import org.jooq.impl.DSL
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl
import org.jooq.types.UInteger
import org.jooq.types.ULong


/**
 * Master Information
 */
@Suppress("UNCHECKED_CAST")
open class SlaveMasterInfo(
    alias: Name,
    path: Table<out Record>?,
    childPath: ForeignKey<out Record, SlaveMasterInfoRecord>?,
    parentPath: InverseForeignKey<out Record, SlaveMasterInfoRecord>?,
    aliased: Table<SlaveMasterInfoRecord>?,
    parameters: Array<Field<*>?>?,
    where: Condition?
): TableImpl<SlaveMasterInfoRecord>(
    alias,
    Mysql.MYSQL,
    path,
    childPath,
    parentPath,
    aliased,
    parameters,
    DSL.comment("Master Information"),
    TableOptions.table(),
    where,
) {
    companion object {

        /**
         * The reference instance of <code>mysql.slave_master_info</code>
         */
        val SLAVE_MASTER_INFO: SlaveMasterInfo = SlaveMasterInfo()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<SlaveMasterInfoRecord> = SlaveMasterInfoRecord::class.java

    /**
     * The column <code>mysql.slave_master_info.Number_of_lines</code>. Number
     * of lines in the file.
     */
    val NUMBER_OF_LINES: TableField<SlaveMasterInfoRecord, UInteger?> = createField(DSL.name("Number_of_lines"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "Number of lines in the file.")

    /**
     * The column <code>mysql.slave_master_info.Master_log_name</code>. The name
     * of the master binary log currently being read from the master.
     */
    val MASTER_LOG_NAME: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Master_log_name"), SQLDataType.CLOB.nullable(false), this, "The name of the master binary log currently being read from the master.")

    /**
     * The column <code>mysql.slave_master_info.Master_log_pos</code>. The
     * master log position of the last read event.
     */
    val MASTER_LOG_POS: TableField<SlaveMasterInfoRecord, ULong?> = createField(DSL.name("Master_log_pos"), SQLDataType.BIGINTUNSIGNED.nullable(false), this, "The master log position of the last read event.")

    /**
     * The column <code>mysql.slave_master_info.Host</code>. The host name of
     * the source.
     */
    val HOST: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Host"), SQLDataType.VARCHAR(255), this, "The host name of the source.")

    /**
     * The column <code>mysql.slave_master_info.User_name</code>. The user name
     * used to connect to the master.
     */
    val USER_NAME: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("User_name"), SQLDataType.CLOB, this, "The user name used to connect to the master.")

    /**
     * The column <code>mysql.slave_master_info.User_password</code>. The
     * password used to connect to the master.
     */
    val USER_PASSWORD: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("User_password"), SQLDataType.CLOB, this, "The password used to connect to the master.")

    /**
     * The column <code>mysql.slave_master_info.Port</code>. The network port
     * used to connect to the master.
     */
    val PORT: TableField<SlaveMasterInfoRecord, UInteger?> = createField(DSL.name("Port"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "The network port used to connect to the master.")

    /**
     * The column <code>mysql.slave_master_info.Connect_retry</code>. The period
     * (in seconds) that the slave will wait before trying to reconnect to the
     * master.
     */
    val CONNECT_RETRY: TableField<SlaveMasterInfoRecord, UInteger?> = createField(DSL.name("Connect_retry"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "The period (in seconds) that the slave will wait before trying to reconnect to the master.")

    /**
     * The column <code>mysql.slave_master_info.Enabled_ssl</code>. Indicates
     * whether the server supports SSL connections.
     */
    val ENABLED_SSL: TableField<SlaveMasterInfoRecord, Boolean?> = createField(DSL.name("Enabled_ssl"), SQLDataType.BOOLEAN.nullable(false), this, "Indicates whether the server supports SSL connections.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_ca</code>. The file used for
     * the Certificate Authority (CA) certificate.
     */
    val SSL_CA: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_ca"), SQLDataType.CLOB, this, "The file used for the Certificate Authority (CA) certificate.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_capath</code>. The path to
     * the Certificate Authority (CA) certificates.
     */
    val SSL_CAPATH: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_capath"), SQLDataType.CLOB, this, "The path to the Certificate Authority (CA) certificates.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_cert</code>. The name of the
     * SSL certificate file.
     */
    val SSL_CERT: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_cert"), SQLDataType.CLOB, this, "The name of the SSL certificate file.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_cipher</code>. The name of
     * the cipher in use for the SSL connection.
     */
    val SSL_CIPHER: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_cipher"), SQLDataType.CLOB, this, "The name of the cipher in use for the SSL connection.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_key</code>. The name of the
     * SSL key file.
     */
    val SSL_KEY: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_key"), SQLDataType.CLOB, this, "The name of the SSL key file.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_verify_server_cert</code>.
     * Whether to verify the server certificate.
     */
    val SSL_VERIFY_SERVER_CERT: TableField<SlaveMasterInfoRecord, Boolean?> = createField(DSL.name("Ssl_verify_server_cert"), SQLDataType.BOOLEAN.nullable(false), this, "Whether to verify the server certificate.")

    /**
     * The column <code>mysql.slave_master_info.Heartbeat</code>.
     */
    val HEARTBEAT: TableField<SlaveMasterInfoRecord, Double?> = createField(DSL.name("Heartbeat"), SQLDataType.FLOAT.nullable(false), this, "")

    /**
     * The column <code>mysql.slave_master_info.Bind</code>. Displays which
     * interface is employed when connecting to the MySQL server
     */
    val BIND: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Bind"), SQLDataType.CLOB, this, "Displays which interface is employed when connecting to the MySQL server")

    /**
     * The column <code>mysql.slave_master_info.Ignored_server_ids</code>. The
     * number of server IDs to be ignored, followed by the actual server IDs
     */
    val IGNORED_SERVER_IDS: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ignored_server_ids"), SQLDataType.CLOB, this, "The number of server IDs to be ignored, followed by the actual server IDs")

    /**
     * The column <code>mysql.slave_master_info.Uuid</code>. The master server
     * uuid.
     */
    val UUID: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Uuid"), SQLDataType.CLOB, this, "The master server uuid.")

    /**
     * The column <code>mysql.slave_master_info.Retry_count</code>. Number of
     * reconnect attempts, to the master, before giving up.
     */
    val RETRY_COUNT: TableField<SlaveMasterInfoRecord, ULong?> = createField(DSL.name("Retry_count"), SQLDataType.BIGINTUNSIGNED.nullable(false), this, "Number of reconnect attempts, to the master, before giving up.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_crl</code>. The file used
     * for the Certificate Revocation List (CRL)
     */
    val SSL_CRL: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_crl"), SQLDataType.CLOB, this, "The file used for the Certificate Revocation List (CRL)")

    /**
     * The column <code>mysql.slave_master_info.Ssl_crlpath</code>. The path
     * used for Certificate Revocation List (CRL) files
     */
    val SSL_CRLPATH: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Ssl_crlpath"), SQLDataType.CLOB, this, "The path used for Certificate Revocation List (CRL) files")

    /**
     * The column <code>mysql.slave_master_info.Enabled_auto_position</code>.
     * Indicates whether GTIDs will be used to retrieve events from the master.
     */
    val ENABLED_AUTO_POSITION: TableField<SlaveMasterInfoRecord, Boolean?> = createField(DSL.name("Enabled_auto_position"), SQLDataType.BOOLEAN.nullable(false), this, "Indicates whether GTIDs will be used to retrieve events from the master.")

    /**
     * The column <code>mysql.slave_master_info.Channel_name</code>. The channel
     * on which the replica is connected to a source. Used in Multisource
     * Replication
     */
    val CHANNEL_NAME: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Channel_name"), SQLDataType.VARCHAR(64).nullable(false), this, "The channel on which the replica is connected to a source. Used in Multisource Replication")

    /**
     * The column <code>mysql.slave_master_info.Tls_version</code>. Tls version
     */
    val TLS_VERSION: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Tls_version"), SQLDataType.CLOB, this, "Tls version")

    /**
     * The column <code>mysql.slave_master_info.Public_key_path</code>. The file
     * containing public key of master server.
     */
    val PUBLIC_KEY_PATH: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Public_key_path"), SQLDataType.CLOB, this, "The file containing public key of master server.")

    /**
     * The column <code>mysql.slave_master_info.Get_public_key</code>.
     * Preference to get public key from master.
     */
    val GET_PUBLIC_KEY: TableField<SlaveMasterInfoRecord, Boolean?> = createField(DSL.name("Get_public_key"), SQLDataType.BOOLEAN.nullable(false), this, "Preference to get public key from master.")

    /**
     * The column <code>mysql.slave_master_info.Network_namespace</code>.
     * Network namespace used for communication with the master server.
     */
    val NETWORK_NAMESPACE: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Network_namespace"), SQLDataType.CLOB, this, "Network namespace used for communication with the master server.")

    /**
     * The column
     * <code>mysql.slave_master_info.Master_compression_algorithm</code>.
     * Compression algorithm supported for data transfer between source and
     * replica.
     */
    val MASTER_COMPRESSION_ALGORITHM: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Master_compression_algorithm"), SQLDataType.VARCHAR(64).nullable(false), this, "Compression algorithm supported for data transfer between source and replica.")

    /**
     * The column
     * <code>mysql.slave_master_info.Master_zstd_compression_level</code>.
     * Compression level associated with zstd compression algorithm.
     */
    val MASTER_ZSTD_COMPRESSION_LEVEL: TableField<SlaveMasterInfoRecord, UInteger?> = createField(DSL.name("Master_zstd_compression_level"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "Compression level associated with zstd compression algorithm.")

    /**
     * The column <code>mysql.slave_master_info.Tls_ciphersuites</code>.
     * Ciphersuites used for TLS 1.3 communication with the master server.
     */
    val TLS_CIPHERSUITES: TableField<SlaveMasterInfoRecord, String?> = createField(DSL.name("Tls_ciphersuites"), SQLDataType.CLOB, this, "Ciphersuites used for TLS 1.3 communication with the master server.")

    /**
     * The column
     * <code>mysql.slave_master_info.Source_connection_auto_failover</code>.
     * Indicates whether the channel connection failover is enabled.
     */
    val SOURCE_CONNECTION_AUTO_FAILOVER: TableField<SlaveMasterInfoRecord, Boolean?> = createField(DSL.name("Source_connection_auto_failover"), SQLDataType.BOOLEAN.nullable(false).defaultValue(DSL.inline("0", SQLDataType.BOOLEAN)), this, "Indicates whether the channel connection failover is enabled.")

    /**
     * The column <code>mysql.slave_master_info.Gtid_only</code>. Indicates if
     * this channel only uses GTIDs and does not persist positions.
     */
    val GTID_ONLY: TableField<SlaveMasterInfoRecord, Boolean?> = createField(DSL.name("Gtid_only"), SQLDataType.BOOLEAN.nullable(false).defaultValue(DSL.inline("0", SQLDataType.BOOLEAN)), this, "Indicates if this channel only uses GTIDs and does not persist positions.")

    private constructor(alias: Name, aliased: Table<SlaveMasterInfoRecord>?): this(alias, null, null, null, aliased, null, null)
    private constructor(alias: Name, aliased: Table<SlaveMasterInfoRecord>?, parameters: Array<Field<*>?>?): this(alias, null, null, null, aliased, parameters, null)
    private constructor(alias: Name, aliased: Table<SlaveMasterInfoRecord>?, where: Condition?): this(alias, null, null, null, aliased, null, where)

    /**
     * Create an aliased <code>mysql.slave_master_info</code> table reference
     */
    constructor(alias: String): this(DSL.name(alias))

    /**
     * Create an aliased <code>mysql.slave_master_info</code> table reference
     */
    constructor(alias: Name): this(alias, null)

    /**
     * Create a <code>mysql.slave_master_info</code> table reference
     */
    constructor(): this(DSL.name("slave_master_info"), null)
    override fun getSchema(): Schema? = if (aliased()) null else Mysql.MYSQL
    override fun getPrimaryKey(): UniqueKey<SlaveMasterInfoRecord> = KEY_SLAVE_MASTER_INFO_PRIMARY
    override fun `as`(alias: String): SlaveMasterInfo = SlaveMasterInfo(DSL.name(alias), this)
    override fun `as`(alias: Name): SlaveMasterInfo = SlaveMasterInfo(alias, this)
    override fun `as`(alias: Table<*>): SlaveMasterInfo = SlaveMasterInfo(alias.qualifiedName, this)

    /**
     * Rename this table
     */
    override fun rename(name: String): SlaveMasterInfo = SlaveMasterInfo(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): SlaveMasterInfo = SlaveMasterInfo(name, null)

    /**
     * Rename this table
     */
    override fun rename(name: Table<*>): SlaveMasterInfo = SlaveMasterInfo(name.qualifiedName, null)

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Condition?): SlaveMasterInfo = SlaveMasterInfo(qualifiedName, if (aliased()) this else null, condition)

    /**
     * Create an inline derived table from this table
     */
    override fun where(conditions: Collection<Condition>): SlaveMasterInfo = where(DSL.and(conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(vararg conditions: Condition?): SlaveMasterInfo = where(DSL.and(*conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Field<Boolean?>?): SlaveMasterInfo = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(condition: SQL): SlaveMasterInfo = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String): SlaveMasterInfo = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String, vararg binds: Any?): SlaveMasterInfo = where(DSL.condition(condition, *binds))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String, vararg parts: QueryPart): SlaveMasterInfo = where(DSL.condition(condition, *parts))

    /**
     * Create an inline derived table from this table
     */
    override fun whereExists(select: Select<*>): SlaveMasterInfo = where(DSL.exists(select))

    /**
     * Create an inline derived table from this table
     */
    override fun whereNotExists(select: Select<*>): SlaveMasterInfo = where(DSL.notExists(select))
}
